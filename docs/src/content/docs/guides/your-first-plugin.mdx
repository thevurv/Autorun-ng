---
title: Your First Plugin
description: A guide to creating your first Autorun-ng plugin
---

import { Aside } from "@astrojs/starlight/components";

<Aside type="caution">
    This guide is largely generated by a language model pending a full rewrite.
</Aside>

This guide will walk you through creating your first plugin for Autorun. By the end, you'll understand the plugin structure, available APIs, and how to create both menu and client-side plugins.

## What is a Plugin?

Plugins in Autorun are self-contained Lua modules that extend functionality. They can:

- Run code in the **menu state** (when the game starts)
- Run code in the **client state** (when you join a server)
- Hook into game events like script loading
- Access a sandboxed filesystem for reading and writing data
- Interact with Source engine interfaces

## Plugin Structure

Plugins live in the `autorun/plugins/` directory relative to the Autorun executable. Each plugin has its own folder with the following structure:

```
autorun/plugins/my-plugin/
├── plugin.toml          # Plugin metadata
└── src/
    ├── menu/
    │   └── init.lua     # Runs once when game starts (optional)
    └── client/
        └── init.lua     # Runs once when joining a server (optional)
```

## Creating Your First Plugin

Let's create a simple plugin that prints a welcome message and tracks the scripts loaded by the game.

### Step 1: Create the Plugin Directory

Navigate to your Autorun directory and create the plugin folder:

```bash
cd autorun/plugins
mkdir my-first-plugin
cd my-first-plugin
```

### Step 2: Create the Plugin Manifest

Create a `plugin.toml` file with your plugin's metadata:

```toml
[plugin]
name = "my-first-plugin"
author = "your-name"
version = "0.1.0"
description = "My first Autorun plugin"
language = "lua"
```

**Fields explained:**

- `name`: Unique identifier for your plugin (lowercase, hyphens allowed)
- `author`: Your name or username
- `version`: Semantic version number (major.minor.patch)
- `description`: Brief description of what your plugin does
- `language`: Always `"lua"` for Lua plugins

### Step 3: Create a Menu Script

Create `src/menu/init.lua`:

```lua
-- This code runs once when the game starts

Autorun.print("Welcome to Autorun!")
Autorun.print("Running version " .. Autorun.VERSION)
Autorun.print("My First Plugin is loaded!")
```

### Step 4: Create a Client Script

Create `src/client/init.lua`:

```lua
-- This code runs once when you join a server
Autorun.print("Connected to server: " .. _G.GetHostName())

-- This runs every single time a Lua script runs in the game
Autorun.on("loadbuffer", function(name, code, mode)

end)
```

### Step 5: Test Your Plugin

1. Launch Autorun
2. Start Garry's Mod
3. Check the Autorun console - you should see your welcome message
4. Join a server - you should see the connection message and script loading logs
5. Check `autorun/plugins/my-first-plugin/data/` for saved scripts

## The Autorun Lua API

Here are the most important functions available to your plugins:

### Console Output

**`Autorun.print(...)`**

Prints messages to the Autorun console.

```lua
Autorun.print("Hello", "World", 123)
-- Output: [Lua] Hello	World	123
```

### File System

**`Autorun.read(path)`**

Reads a file from your plugin's directory (read-only).

```lua
local config = Autorun.read("config.lua")
if config then
    Autorun.print("Config loaded!")
end
```

**`Autorun.write(path, content)`**

Synchronously writes a file to your plugin's `data/` directory.

```lua
Autorun.write("config.txt", "enabled = true")
```

**`Autorun.writeAsync(path, content)`**

Asynchronously writes a file. **Use this instead of `write()` to avoid anti-cheat detection!**

```lua
Autorun.writeAsync("logs/output.txt", "Server connected")
```

**`Autorun.mkdir(path)`**

Creates a directory in your plugin's `data/` directory.

```lua
local created = Autorun.mkdir("logs/2025")
if created then
    Autorun.print("Directory created")
end
```

### Code Loading

**`Autorun.include(path)`**

Loads and executes a Lua file from your plugin directory. No caching - runs every time.

```lua
Autorun.include("helpers.lua")
```

**`Autorun.require(path)`**

Loads and executes a Lua file with caching. Subsequent calls return cached results.

```lua
local utils = Autorun.require("utils.lua")
```

### Events

**`Autorun.on(eventName, callback)`**

Registers a callback for an event. Returns a handler object with a `:remove()` method.

```lua
local handler = Autorun.on("loadbuffer", function(scriptName, scriptCode, mode)
    Autorun.print("Loading: " .. scriptName)

    -- Return non-nil to stop event propagation
    -- Return nil/false to let other handlers run
end)

-- Later, to unregister:
handler:remove()
```

**Available Events:**

- `loadbuffer` - Fires when Lua code is loaded or executed
    - Parameters: `scriptName` (string), `scriptCode` (string), `mode` (string)
    - Return non-nil to stop propagation

### Properties

**`Autorun.VERSION`**

The current version of Autorun.

```lua
Autorun.print("Running Autorun " .. Autorun.VERSION)
```

## Example: Script Logger Plugin

Here's a complete example that logs all loaded scripts with timestamps:

**plugin.toml:**

```toml
[plugin]
name = "script-logger"
author = "your-name"
version = "1.0.0"
description = "Logs all loaded scripts with timestamps"
language = "lua"
```

**src/client/init.lua:**

```lua
local serverName = string.match(_G.GetHostName(), "^([%w_%-][%w _%-']*)$") or "unknown"
local logFile = serverName .. "/load_log.txt"

Autorun.print("Script Logger started for: " .. serverName)

-- Create server directory
Autorun.mkdir(serverName)

-- Write initial log header
local timestamp = os.date("%Y-%m-%d %H:%M:%S")
Autorun.write(logFile, "Script Load Log - " .. timestamp .. "\n")

-- Hook script loading
Autorun.on("loadbuffer", function(scriptName, scriptCode, mode)
    local timestamp = os.date("%H:%M:%S")
    local logEntry = string.format("[%s] %s (%d bytes)\n",
                                   timestamp,
                                   scriptName,
                                   #scriptCode)

    -- Read existing log
    local existingLog = Autorun.read("../data/" .. logFile) or ""

    -- Append new entry
    Autorun.writeAsync(logFile, existingLog .. logEntry)
end)
```

## Best Practices

1. **Use `writeAsync()` for file operations** - This prevents anti-cheat detection by avoiding main thread blocking
2. **Sanitize file paths** - Always validate and clean user input before using in file paths
3. **Handle nil returns** - File operations can fail, always check return values
4. **Use descriptive names** - Plugin names should be clear and lowercase with hyphens
5. **Create directories first** - Use `mkdir()` before writing files to nested paths
6. **Clean up event handlers** - Remove handlers when they're no longer needed
7. **Test in both states** - If your plugin has both menu and client code, test both

## Security & Sandboxing

Autorun plugins run in a sandboxed environment:

- File access is limited to your plugin's directory
- Only safe Lua standard libraries are available
- All Autorun functions verify they're running in an authorized environment
- File writes go to a dedicated `data/` directory

## Troubleshooting

**My plugin isn't loading**

- Check `plugin.toml` syntax
- Ensure the plugin directory name matches the `name` field
- Check for Lua syntax errors in your scripts

**File operations aren't working**

- Verify paths are relative, not absolute
- Ensure parent directories exist (use `mkdir()`)
- Check the Autorun console for error messages

**Events aren't firing**

- Make sure you're in the right state (menu vs client)
- Check that event names are spelled correctly
- Verify your callback function signature matches the event

## Next Steps

Now that you've created your first plugin, you can:

- Explore the example plugins in `release/autorun/plugins/`
- Study the `lua_dumper` plugin for advanced file operations
- Study the `greeter` plugin for ASCII art and menu state usage
- Experiment with the `loadbuffer` event to analyze game scripts
- Read the source code in `packages/autorun-core` to understand internals

Happy coding!
