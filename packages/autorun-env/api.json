{
	"namespaces": [
		{
			"name": "Autorun",
			"description": "Main Autorun-ng namespace",
			"realm": "shared",
			"fields": [
				{
					"name": "PLUGIN",
					"type": "userdata",
					"description": "Currently running plugin pointer. Don't touch this.",
					"realm": "shared"
				},
				{
					"name": "VERSION",
					"type": "string",
					"description": "Version of Autorun-ng using semver format",
					"realm": "shared"
				},
				{
					"name": "EVENTS",
					"type": "table<string, table<integer, function>>",
					"description": "Internal event registry. Don't modify this directly, use Autorun.on() instead.",
					"realm": "shared"
				}
			],
			"functions": [
				{
					"name": "print",
					"description": "Prints to the Autorun console in the format of '[plugin-name] ...'. Note you can print ANSI to get colors, see Autorun.color",
					"realm": "shared",
					"parameters": [
						{
							"name": "values",
							"type": "...any",
							"description": "Values to print"
						}
					],
					"returns": []
				},
				{
					"name": "read",
					"description": "Reads a path relative to the active plugin's directory.",
					"realm": "shared",
					"parameters": [
						{
							"name": "path",
							"type": "string"
						}
					],
					"returns": [
						{
							"type": "string?",
							"description": "Contents of the file, nil if failed to read"
						}
					]
				},
				{
					"name": "write",
					"description": "Writes to a path relative to the active plugin's /data/ directory. Cannot write outside /data/ for security reasons.",
					"realm": "shared",
					"parameters": [
						{
							"name": "path",
							"type": "string"
						},
						{
							"name": "content",
							"type": "string"
						}
					],
					"returns": []
				},
				{
					"name": "append",
					"description": "Appends content to a file at the given path relative to the active plugin's /data/ directory. Cannot write outside /data/ for security reasons.",
					"realm": "shared",
					"parameters": [
						{
							"name": "path",
							"type": "string"
						},
						{
							"name": "content",
							"type": "string"
						}
					],
					"returns": []
				},
				{
					"name": "writeAsync",
					"description": "ASYNCHRONOUSLY writes to a path relative to the active plugin's /data/ directory. Cannot write outside /data/ for security reasons. This is important to avoid blocking the main thread on large writes to avoid detection.",
					"realm": "shared",
					"parameters": [
						{
							"name": "path",
							"type": "string"
						},
						{
							"name": "content",
							"type": "string"
						}
					],
					"returns": []
				},
				{
					"name": "include",
					"description": "Reads and executes a Lua file from the given path. This doesn't do any caching.",
					"realm": "shared",
					"parameters": [
						{
							"name": "path",
							"type": "string"
						}
					],
					"returns": [
						{
							"type": "...any"
						}
					]
				},
				{
					"name": "require",
					"description": "Reads and executes a Lua file from the given path. This caches the output of the include so subsequent calls return the same values.",
					"realm": "shared",
					"parameters": [
						{
							"name": "path",
							"type": "string"
						}
					],
					"returns": [
						{
							"type": "...any"
						}
					]
				},
				{
					"name": "mkdir",
					"description": "Makes a directory recursively. This runs relative to the plugin's /data/ directory",
					"realm": "shared",
					"parameters": [
						{
							"name": "path",
							"type": "string"
						}
					],
					"returns": [
						{
							"type": "boolean",
							"description": "Whether the directory was created successfully, false if exists"
						}
					]
				},
				{
					"name": "exists",
					"description": "Checks if a file or directory exists at the given path relative to the active plugin's directory.",
					"realm": "shared",
					"parameters": [
						{
							"name": "path",
							"type": "string"
						}
					],
					"returns": [
						{
							"type": "boolean",
							"description": "True if the file/directory exists, false otherwise"
						}
					]
				},
				{
					"name": "on",
					"description": "Registers an event handler for the specified event.",
					"realm": "shared",
					"parameters": [
						{
							"name": "eventName",
							"type": "string",
							"description": "Name of the event to listen for (e.g., 'loadbuffer')"
						},
						{
							"name": "callback",
							"type": "function",
							"description": "Function to call when the event is triggered. Return value can modify event behavior."
						}
					]
				},
				{
					"name": "onRemote",
					"description": "Registers an event handler for the specified remote event.",
					"realm": "shared",
					"parameters": [
						{
							"name": "eventName",
							"type": "string",
							"description": "Name of the event to listen for (e.g., 'loadbuffer')"
						},
						{
							"name": "callback",
							"type": "function",
							"description": "Function to call when the event is received. It will be passed the single serializable value"
						}
					]
				},
				{
					"name": "trigger",
					"description": "Triggers all registered handlers for the specified event. Used internally by Autorun.",
					"realm": "shared",
					"parameters": [
						{
							"name": "eventName",
							"type": "string",
							"description": "Name of the event to trigger"
						},
						{
							"name": "...",
							"type": "...any",
							"description": "Arguments to pass to event handlers"
						}
					],
					"returns": [
						{
							"type": "any?",
							"description": "First non-nil return value from event handlers, or nil"
						}
					]
				},
				{
					"name": "triggerRemote",
					"description": "Triggers an event registered with Autorun.onRemote on the other state. AKA, if you're on the menu and call this, it will send an event to the client, and vice versa.",
					"realm": "shared",
					"parameters": [
						{
							"name": "eventName",
							"type": "string",
							"description": "Name of the event to trigger"
						},
						{
							"name": "value",
							"type": "string | number | boolean",
							"description": "Serializable value to pass to the event handlers"
						}
					]
				},
				{
					"name": "detour",
					"description": "Creates a detour (hook) on a target Lua function, redirecting calls to a replacement function. The detour is automatically enabled upon creation. The original function is passed as the first argument to the detour callback, followed by the original arguments.",
					"realm": "shared",
					"parameters": [
						{
							"name": "targetFunction",
							"type": "function",
							"description": "The function to detour/hook"
						},
						{
							"name": "detourCallback",
							"type": "function",
							"description": "The function to call instead of the target. Receives the original function as the first argument, followed by all arguments passed to the hooked function. Example: function(original, ...) return original(...) end"
						}
					],
					"returns": [
						{
							"type": "Detour",
							"description": "Detour userdata object that can be used to manage the detour"
						}
					]
				},
				{
					"name": "enableDetour",
					"description": "Enables a previously disabled detour, causing calls to the target function to be redirected again.",
					"realm": "shared",
					"parameters": [
						{
							"name": "detour",
							"type": "Detour",
							"description": "The detour userdata to enable"
						}
					],
					"returns": []
				},
				{
					"name": "disableDetour",
					"description": "Disables a detour, restoring the original function behavior. The detour can be re-enabled later with enableDetour().",
					"realm": "shared",
					"parameters": [
						{
							"name": "detour",
							"type": "Detour",
							"description": "The detour userdata to disable"
						}
					],
					"returns": []
				},
				{
					"name": "removeDetour",
					"description": "Permanently removes a detour, disabling it and cleaning up all associated resources. The detour cannot be used after this.",
					"realm": "shared",
					"parameters": [
						{
							"name": "detour",
							"type": "Detour",
							"description": "The detour userdata to remove"
						}
					],
					"returns": []
				},
				{
					"name": "getOriginalFunction",
					"description": "Retrieves the original function pointer from a detour. This is rarely needed since the original function is automatically passed as the first argument to the detour callback. Useful for code outside the detour callback that needs to call the original function.",
					"realm": "shared",
					"parameters": [
						{
							"name": "detour",
							"type": "Detour",
							"description": "The detour userdata to get the original function from"
						}
					],
					"returns": [
						{
							"type": "function",
							"description": "The original function that was detoured"
						}
					]
				},
				{
					"name": "copyFastFunction",
					"description": "Creates a copy of a specific LuaJIT fast function, with the internals replaced by running the given lua closure. Basically, allows you to 'detour' certain functions like getfenv or getmetatable which LuaJIT JIT compiles.",
					"realm": "shared",
					"parameters": [
						{
							"name": "originalFunction",
							"type": "function",
							"description": "The original fast function to copy. Must be a C function obviously."
						},
						{
							"name": "replacementFunction",
							"type": "function",
							"description": "The Lua function to run instead of the original."
						}
					],
					"returns": [
						{
							"type": "function",
							"description": "The copied function that looks like the original but runs the replacement code. To lua, this will look like just another C function. Note that anything that gets a stack trace will still see your Lua function and detect you if you do anything that'll give you away."
						}
					]
				},
				{
					"name": "isFunctionAuthorized",
					"description": "Checks if a given function or stack level is authorized by the Autorun environment.",
					"realm": "shared",
					"parameters": [
						{
							"name": "funcOrLevel",
							"type": "function | number",
							"description": "The function to check or the stack level"
						}
					],
					"returns": [
						{
							"type": "boolean",
							"description": "True if the function/level is authorized, false otherwise"
						}
					]
				},
				{
					"name": "isProtoAuthorized",
					"description": "Checks if a given prototype is authorized by the Autorun environment. This can be used to verify if protos from VM events are from Autorun or not.",
					"realm": "shared",
					"parameters": [
						{
							"name": "proto",
							"type": "proto",
							"description": "The prototype to check"
						}
					],
					"returns": [
						{
							"type": "boolean",
							"description": "True if the prototype is authorized, false otherwise"
						}
					]
				},
				{
					"name": "load",
					"description": "Compiles a Lua string into a callable function without executing it. Similar to Lua's loadstring/load function. Use this to dynamically compile code at runtime. NOTE: The environment inside defaults to the global environment, NOT Autorun's environment.",
					"realm": "shared",
					"parameters": [
						{
							"name": "code",
							"type": "string",
							"description": "The Lua code to compile"
						}
					],
					"returns": [
						{
							"type": "function?",
							"description": "The compiled function, or nil if compilation failed"
						},
						{
							"type": "string?",
							"description": "Error message if compilation failed"
						}
					]
				},
				{
					"name": "color",
					"description": "This allows you to format a range of input colors (hex strings, hex numbers, rgb tables, color names) into a variety of outputs. For example, you can convert 'red' to '#FF0000' by calling Autorun.color('red', 'hex'). Most useful output is probably 'ansi' which is the default and can be used in conjunction with Autorun.print to print colors to the console.\nList of output formats:\n- ansi\n- hex\n- number\n- [rgb]\n- {rgb}\n",
					"realm": "shared",
					"parameters": [
						{
							"name": "input",
							"type": "string | number | table",
							"description": "Input color in various formats (e.g., '#FF0000', 0xFF0000, {r=255,g=0,b=0}, 'red')"
						},
						{
							"name": "outputFormat",
							"type": "string?",
							"description": "Desired output format ('hex', 'rgb', 'ansi'). Defaults to 'ansi'."
						}
					],
					"returns": [
						{
							"type": "string | number | table",
							"description": "Formatted color in the requested output format"
						}
					]
				}
			]
		}
	],
	"classes": [
		{
			"name": "Detour",
			"description": "Userdata object representing a function detour/hook. Contains internal state for managing the detour, trampoline functions, and the original function pointer. Created by Autorun.detour().",
			"realm": "shared",
			"fields": [],
			"methods": []
		}
	],
	"events": [
		{
			"name": "loadbuffer",
			"description": "Called when Lua code is about to be loaded and executed. Can be used to modify, block, or replace the code before execution.",
			"realm": "client",
			"parameters": [
				{
					"name": "name",
					"type": "string",
					"description": "Name/identifier of the chunk being loaded"
				},
				{
					"name": "content",
					"type": "string",
					"description": "The Lua code content to be executed"
				},
				{
					"name": "mode",
					"type": "string",
					"description": "Load mode ('t' for text, 'b' for binary, 'bt' for both)"
				}
			],
			"returns": [
				{
					"type": "boolean | string | nil",
					"description": "Return true to block execution, return a string to replace the code, or return nil to allow normal execution"
				}
			]
		}
	]
}
